$:.unshift File.expand_path(File.dirname(__FILE__))
require 'concurrent/fiber'
require 'timeout'

module Kernel
  def sleep(time=nil)
    NB::Fiber.yield if time.nil?
    return if time <= 0
    fiber = NB::Fiber.current
    NB.reactor.add_timer(time){fiber.resume}
    NB::Fiber.yield
  end

  def system(cmd, *args)
    begin
      backticks(cmd, *args)
      result = $?.exitstatus
      return true if result.zero?
      return nil if result == 127
      return false
    rescue Errno::ENOENT => e
      return nil
    end
  end

  def backticks(cmd, *args)
    myargs = "#{cmd} "
    myargs << args.join(' ') if args
    res = ''    
    IO.popen(myargs) do |f|
      res << f.read
    end
    res
  end
  
end

NB.reactor.on_add_timer do |timer|
  timeouts = NB::Fiber.current[:timeouts]
  unless timeouts.nil? || timeouts.empty?
    timeouts.last << timer
  end
end

NB.reactor.on_attach do |mode, io|
  timeouts = NB::Fiber.current[:timeouts]
  unless timeouts.nil? || timeouts.empty?
    timeouts.last << [mode, io]
  end
end

def NB.reactor.on_detach(mode, io)
  fiber = NB::Fiber.current
  unless timeouts.nil? || timeouts.empty?
    timeouts.delete_if{|to|to.is_a? Array && to[0] == mode && to[1] == io}
  end
end

module Timeout

  def timeout(time, klass=Timeout::Error)
    if time <= 0
      yield
    else
      fiber = NB::Fiber.current
      timer = NB.reactor.add_timer(time) do 
        fiber[:timeouts].last.each do |event|
          if event.is_a? Reactor::Timer
            event.cancel
          else
            NB.reactor.detach(event[0], event[1])
          end
        end
        fiber.resume(klass.new)
      end
      fiber[:timeouts] = [] unless fiber[:timeout] 
      fiber[:timeouts] << []
      begin
        yield
      rescue Exception => e
        raise e        
      ensure
        timer.cancel  
        fiber[:timeouts].pop
      end
    end
  end
  
  module_function :timeout  

end
