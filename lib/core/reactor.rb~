require 'reactor'

module NeverBlock

  @@reactors = {}

  def self.reactor
    @@reactors[Thread.current.object_id] ||= ::Reactor::Base.new
  end

  NB.reactor.on_add_timer do |timer|
    timeouts = NB::Fiber.current[:timeouts]
    unless timeouts.nil? || timeouts.empty?
      timeouts.last << timer
    end
  end

  NB.reactor.on_attach do |mode, io|
    timeouts = NB::Fiber.current[:timeouts]
    unless timeouts.nil? || timeouts.empty?
      timeouts.last << [mode, io]
    end
  end

  NB.reactor.on_detach(mode, io) do |mode, io|
    timeouts = NB::Fiber.current[:timeouts]
    unless timeouts.nil? || timeouts.empty?
      timeouts.delete_if{|to|to.is_a? Array && to[0] == mode && to[1] == io}
    end
  end

end

=begin
  module Backend
    module Reactor

      include NeverBlock::Reactor

      def attach_to_reactor(mode = :read)
        if reactor = NeverBlock::Reactor.reactor
			    @fiber = Fiber.current
          reactor.attach(mode, self)
          Fiber.yield
			    reactor.detach(mode, self)
        else
          raise ::NB::NBError.new("NB::Backend::Reactor: Reactor not found")
        end
      end  

      # This is called whenever the socket available
      def resume
		    if @fiber then
			    if(@fiber['timeout_value']) then
					    @fiber[:exceeded_timeout] = true if (Time.now.to_i > @fiber['timeout_value'] + @fiber['starting_time'])
			    end
		      @fiber.resume
		    end
      end

      def notify_readable(reactor)
        resume  
      end
      
      def notify_writable(reactor)
        resume
      end

    end
  end    
  
end
=end
